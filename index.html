<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ç›¸æœºæµ·æŠ¥">
    <meta name="theme-color" content="#ff4757">
    <meta name="description" content="ä¸“ä¸šçš„ç›¸æœºæµ·æŠ¥ç”Ÿæˆå™¨ï¼Œæ”¯æŒå‰ªå½±æ•ˆæœå’Œè‡ªå®šä¹‰é¢œè‰²">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS Icons -->
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <title>ç›¸æœºæµ·æŠ¥ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            height: 100dvh;
            position: fixed;
            width: 100%;
        }

        .app-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* ç›¸æœºé¢„è§ˆåŒºåŸŸ */
        .camera-section {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: pan-x pan-y pinch-zoom;
        }

        /* æ‘„åƒå¤´åˆ‡æ¢æŒ‰é’® */
        .camera-switch-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .camera-switch-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        .camera-switch-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        /* æ–¹å‘é”å®šæŒ‰é’® */
        .orientation-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .orientation-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        .orientation-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .orientation-btn.locked {
            background: rgba(255, 107, 107, 0.3);
            border-color: rgba(255, 107, 107, 0.5);
        }

        /* æ¨ªå±æ¨¡å¼ */
        .camera-section.landscape {
            flex-direction: row;
        }

        .camera-section.landscape #camera-preview {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* ç¼©æ”¾æ§åˆ¶ */
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 15px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            z-index: 20;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            touch-action: manipulation;
            user-select: none;
        }

        .zoom-btn:active {
            transform: scale(0.9);
            background: rgba(255, 255, 255, 0.3);
        }

        .zoom-slider {
            width: 150px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .zoom-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .zoom-value {
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            min-width: 35px;
            text-align: center;
        }

        #camera-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }

        #photo-canvas {
            display: none;
        }

        /* é¢„è§ˆæ•ˆæœcanvas */
        #preview-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 5;
            pointer-events: none;
            transition: transform 0.1s ease-out;
            transform-origin: center center;
        }

        /* æ­£æ–¹å½¢æ‹æ‘„æ¡† */
        .square-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            max-width: min(80vw, 80vh);
            max-height: min(80vw, 80vh);
            border: 3px dashed rgba(255, 255, 255, 0.8);
            pointer-events: none;
            z-index: 15;
            display: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        }

        .square-frame.active {
            display: block;
        }


        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 50vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* é¢œè‰²é€‰æ‹©å™¨ */
        .color-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .color-selector h3 {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 5px;
        }

        .color-options {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .color-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .color-btn.active {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .color-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .color-btn:active::after {
            opacity: 1;
        }

        .secondary-btn.active {
            background: rgba(255, 107, 107, 0.3);
            border-color: rgba(255, 107, 107, 0.5);
        }

        /* è‰²ç¯é€‰æ‹©å™¨ */
        .color-wheel-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .color-wheel-wrapper {
            position: relative;
            width: 200px;
            height: 200px;
            margin: 0 auto;
        }

        #color-wheel {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            cursor: crosshair;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .color-picker-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 3px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .selected-color-display {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            margin: 0 auto;
        }

        .color-picker-toggle {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .color-picker-toggle:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .color-picker-toggle:active {
            transform: scale(0.95);
        }


        /* æ“ä½œæŒ‰é’® */
        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .primary-btn, .secondary-btn {
            flex: 1;
            min-width: 120px;
            padding: 14px 20px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
        }

        .primary-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            color: #fff;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .primary-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .secondary-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.3);
        }

        /* æ‹æ‘„ç»“æœå±•ç¤º */
        .result-section {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .result-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            max-height: 80vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #result-image {
            width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }

        .result-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 101;
        }

        .result-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            transition: all 0.3s;
        }

        .result-btn:active {
            transform: scale(0.95);
        }

        /* åŠ è½½æç¤º */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px 30px;
            border-radius: 12px;
            z-index: 1000;
            display: none;
        }

        .loading.show {
            display: block;
        }

        /* é”™è¯¯æç¤º */
        .error-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 0, 0, 0.9);
            color: #fff;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            font-size: 14px;
        }

        .error-message.show {
            display: block;
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 480px) {
            .control-panel {
                padding: 12px;
                gap: 12px;
            }

            .color-btn {
                width: 45px;
                height: 45px;
            }

            .primary-btn, .secondary-btn {
                font-size: 14px;
                padding: 12px 16px;
            }
        }

        /* éšè—æ»šåŠ¨æ¡ä½†ä¿æŒæ»šåŠ¨åŠŸèƒ½ */
        .control-panel::-webkit-scrollbar {
            width: 4px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: transparent;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- ç›¸æœºé¢„è§ˆåŒºåŸŸ -->
        <div class="camera-section">
            <video id="camera-preview" autoplay playsinline></video>
            <canvas id="preview-canvas"></canvas>
            <canvas id="photo-canvas"></canvas>
            <button class="camera-switch-btn" id="switch-camera-btn" title="åˆ‡æ¢æ‘„åƒå¤´">ğŸ”„</button>
            <button class="orientation-btn" id="orientation-btn" title="é”å®šæ–¹å‘">ğŸ”“</button>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoom-out-btn" title="ç¼©å°">âˆ’</button>
                <input type="range" class="zoom-slider" id="zoom-slider" min="0.3" max="3" step="0.1" value="1">
                <span class="zoom-value" id="zoom-value">1.0x</span>
                <button class="zoom-btn" id="zoom-in-btn" title="æ”¾å¤§">+</button>
            </div>
            <div class="square-frame" id="square-frame"></div>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <!-- é¢œè‰²é€‰æ‹©å™¨ -->
            <div class="color-selector">
                <h3>é¢œè‰²ä¸»é¢˜</h3>
                <div class="color-options">
                    <button class="color-btn active" data-color="red" style="background: linear-gradient(135deg, #ff4757, #ee5a6f);" title="çº¢è‰²"></button>
                    <button class="color-btn" data-color="blue" style="background: linear-gradient(135deg, #3742fa, #2f3542);" title="è“è‰²"></button>
                    <button class="color-btn" data-color="green" style="background: linear-gradient(135deg, #2ed573, #1e90ff);" title="ç»¿è‰²"></button>
                    <button class="color-btn" data-color="yellow" style="background: linear-gradient(135deg, #ffa502, #ff6348);" title="é»„è‰²"></button>
                    <button class="color-btn" data-color="purple" style="background: linear-gradient(135deg, #a55eea, #8854d0);" title="ç´«è‰²"></button>
                    <button class="color-btn" data-color="orange" style="background: linear-gradient(135deg, #ff6b6b, #ffa502);" title="æ©™è‰²"></button>
                </div>
                <button class="color-picker-toggle" id="color-picker-toggle">ğŸ¨ è‡ªå®šä¹‰é¢œè‰²</button>
                <div class="color-wheel-container" id="color-wheel-container" style="display: none;">
                    <div class="color-wheel-wrapper">
                        <canvas id="color-wheel"></canvas>
                        <div class="color-picker-indicator" id="color-indicator"></div>
                    </div>
                    <div class="selected-color-display" id="selected-color-display"></div>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’® -->
            <div class="action-buttons">
                <button id="upload-btn" class="secondary-btn" title="ä¸Šä¼ å›¾ç‰‡">ğŸ“ ä¸Šä¼ </button>
                <button id="square-mode-btn" class="secondary-btn" title="æ­£æ–¹å½¢æ¨¡å¼">â¬œ</button>
                <button id="capture-btn" class="primary-btn">ğŸ“· æ‹æ‘„</button>
                <button id="reset-btn" class="secondary-btn">ğŸ”„ é‡ç½®</button>
            </div>
            <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
            <input type="file" id="file-input" accept="image/*" style="display: none;">
        </div>

        <!-- æ‹æ‘„ç»“æœå±•ç¤º -->
        <div class="result-section" id="result-section">
            <div class="result-container">
                <img id="result-image" src="" alt="æ‹æ‘„ç»“æœ">
            </div>
            <div class="result-controls">
                <button class="result-btn" id="download-btn">ğŸ’¾ ä¸‹è½½</button>
                <button class="result-btn" id="close-result-btn">âœ• å…³é—­</button>
            </div>
        </div>

        <!-- åŠ è½½æç¤º -->
        <div class="loading" id="loading">å¤„ç†ä¸­...</div>

        <!-- é”™è¯¯æç¤º -->
        <div class="error-message" id="error-message"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let stream = null;
        let currentColor = 'red';
        let currentFacingMode = 'environment'; // 'environment' åç½®, 'user' å‰ç½®
        let customColor = { r: 255, g: 71, b: 87 }; // è‡ªå®šä¹‰é¢œè‰²
        let isUsingCustomColor = false;
        let isSquareMode = false; // æ­£æ–¹å½¢æ‹æ‘„æ¨¡å¼
        let uploadedImage = null; // ä¸Šä¼ çš„å›¾ç‰‡
        let isUsingUploadedImage = false; // æ˜¯å¦ä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡
        let currentZoom = 1.0;
        let initialDistance = 0;
        let lastZoom = 1.0;
        let orientationLocked = false;
        let currentOrientation = 'portrait'; // 'portrait' ç«–å±, 'landscape' æ¨ªå±

        // DOMå…ƒç´ 
        const video = document.getElementById('camera-preview');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const canvas = document.getElementById('photo-canvas');
        const ctx = canvas.getContext('2d');
        const colorButtons = document.querySelectorAll('.color-btn');
        const colorWheel = document.getElementById('color-wheel');
        const colorWheelCtx = colorWheel.getContext('2d');
        const colorIndicator = document.getElementById('color-indicator');
        const selectedColorDisplay = document.getElementById('selected-color-display');
        const colorPickerToggle = document.getElementById('color-picker-toggle');
        const colorWheelContainer = document.getElementById('color-wheel-container');
        const captureBtn = document.getElementById('capture-btn');
        const resetBtn = document.getElementById('reset-btn');
        const uploadBtn = document.getElementById('upload-btn');
        const fileInput = document.getElementById('file-input');
        const squareModeBtn = document.getElementById('square-mode-btn');
        const squareFrame = document.getElementById('square-frame');
        const resultSection = document.getElementById('result-section');
        const resultImage = document.getElementById('result-image');
        const downloadBtn = document.getElementById('download-btn');
        const closeResultBtn = document.getElementById('close-result-btn');
        const switchCameraBtn = document.getElementById('switch-camera-btn');
        const orientationBtn = document.getElementById('orientation-btn');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomValue = document.getElementById('zoom-value');
        const cameraSection = document.querySelector('.camera-section');
        const loading = document.getElementById('loading');
        const errorMessage = document.getElementById('error-message');

        // é¢œè‰²é…ç½® - çº¯è‰²èƒŒæ™¯
        const colorConfigs = {
            red: { r: 255, g: 71, b: 87 },
            blue: { r: 55, g: 66, b: 250 },
            green: { r: 46, g: 213, b: 115 },
            yellow: { r: 255, g: 165, b: 2 },
            purple: { r: 165, g: 94, b: 234 },
            orange: { r: 255, g: 107, b: 107 }
        };

        // åˆå§‹åŒ–
        async function init() {
            try {
                await startCamera();
                setupEventListeners();
                resultSection.style.display = 'none';
                drawColorWheel(); // ç»˜åˆ¶è‰²ç¯
                // åˆå§‹åŒ–é»˜è®¤é¢œè‰²æ˜¾ç¤º
                selectedColorDisplay.style.backgroundColor = `rgb(${customColor.r}, ${customColor.g}, ${customColor.b})`;
                startPreviewLoop(); // å¯åŠ¨é¢„è§ˆå¾ªç¯
            } catch (error) {
                showError('æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
                console.error('åˆå§‹åŒ–é”™è¯¯:', error);
            }
        }

        // ç»˜åˆ¶è‰²ç¯
        function drawColorWheel() {
            const size = 200;
            const center = size / 2;
            const radius = size / 2 - 10;
            
            colorWheel.width = size;
            colorWheel.height = size;
            
            for (let angle = 0; angle < 360; angle += 0.5) {
                const rad = (angle * Math.PI) / 180;
                const distance = radius;
                
                for (let r = 0; r <= distance; r += 1) {
                    const x = center + Math.cos(rad) * r;
                    const y = center + Math.sin(rad) * r;
                    
                    // è®¡ç®—HSLé¢œè‰²
                    const hue = angle;
                    const saturation = (r / distance) * 100;
                    const lightness = 50;
                    
                    const rgb = hslToRgb(hue / 360, saturation / 100, lightness / 100);
                    colorWheelCtx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
                    colorWheelCtx.fillRect(x, y, 1, 1);
                }
            }
        }

        // HSLè½¬RGB
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // è·å–è‰²ç¯ä¸Šçš„é¢œè‰²
        function getColorFromWheel(x, y) {
            const rect = colorWheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const radius = rect.width / 2 - 10;
            
            if (distance > radius) return null;
            
            const angle = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
            const saturation = Math.min(100, (distance / radius) * 100);
            
            const rgb = hslToRgb(angle / 360, saturation / 100, 0.5);
            return { r: rgb[0], g: rgb[1], b: rgb[2] };
        }

        // é¢„è§ˆå¾ªç¯
        let previewAnimationId = null;
        function startPreviewLoop() {
            function updatePreview() {
                if (isUsingUploadedImage && uploadedImage) {
                    // ä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡
                    updatePreviewFromImage();
                } else if (video.readyState === video.HAVE_ENOUGH_DATA && video.videoWidth > 0) {
                    // ä½¿ç”¨æ‘„åƒå¤´
                    updatePreviewFromVideo();
                }
                
                previewAnimationId = requestAnimationFrame(updatePreview);
            }
            
            updatePreview();
        }

        // ä»è§†é¢‘æ›´æ–°é¢„è§ˆ
        function updatePreviewFromVideo() {
            // è®¾ç½®é¢„è§ˆcanvaså°ºå¯¸
            previewCanvas.width = video.videoWidth;
            previewCanvas.height = video.videoHeight;
            
            // ç»˜åˆ¶è§†é¢‘å¸§ï¼ˆè€ƒè™‘ç¼©æ”¾å’Œé•œåƒï¼‰
            previewCtx.save();
            
            // å¦‚æœæ˜¯å‰ç½®æ‘„åƒå¤´ï¼Œéœ€è¦é•œåƒ
            if (currentFacingMode === 'user') {
                previewCtx.scale(-1, 1);
                previewCtx.translate(-previewCanvas.width, 0);
            }
            
            const scaledWidth = video.videoWidth * currentZoom;
            const scaledHeight = video.videoHeight * currentZoom;
            const offsetX = (video.videoWidth - scaledWidth) / 2;
            const offsetY = (video.videoHeight - scaledHeight) / 2;
            
            previewCtx.drawImage(video, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // åº”ç”¨é¢œè‰²æ»¤é•œ
            applyPreviewFilter(currentColor);
            
            previewCtx.restore();
        }

        // ä»å›¾ç‰‡æ›´æ–°é¢„è§ˆ
        function updatePreviewFromImage() {
            if (!uploadedImage) return;
            
            // è®¡ç®—é¢„è§ˆå°ºå¯¸ï¼ˆä¿æŒå®½é«˜æ¯”ï¼‰
            const container = cameraSection;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const imgAspect = uploadedImage.width / uploadedImage.height;
            const containerAspect = containerWidth / containerHeight;
            
            let displayWidth, displayHeight;
            if (imgAspect > containerAspect) {
                displayWidth = containerWidth;
                displayHeight = containerWidth / imgAspect;
            } else {
                displayHeight = containerHeight;
                displayWidth = containerHeight * imgAspect;
            }
            
            // è®¾ç½®canvaså°ºå¯¸ä¸ºå›¾ç‰‡åŸå§‹å°ºå¯¸
            previewCanvas.width = uploadedImage.width;
            previewCanvas.height = uploadedImage.height;
            
            // ç»˜åˆ¶å›¾ç‰‡ï¼ˆè€ƒè™‘ç¼©æ”¾ï¼‰
            previewCtx.save();
            
            const scaledWidth = uploadedImage.width * currentZoom;
            const scaledHeight = uploadedImage.height * currentZoom;
            const offsetX = (uploadedImage.width - scaledWidth) / 2;
            const offsetY = (uploadedImage.height - scaledHeight) / 2;
            
            previewCtx.drawImage(uploadedImage, offsetX, offsetY, scaledWidth, scaledHeight);
            
            // åº”ç”¨é¢œè‰²æ»¤é•œ
            applyPreviewFilter(currentColor);
            
            previewCtx.restore();
        }

        // å¤„ç†å›¾ç‰‡ä¸Šä¼ 
        function handleImageUpload(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    isUsingUploadedImage = true;
                    // åœæ­¢è§†é¢‘é¢„è§ˆå¾ªç¯ï¼Œä½¿ç”¨å›¾ç‰‡é¢„è§ˆ
                    stopPreviewLoop();
                    startPreviewLoop();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // åœæ­¢é¢„è§ˆå¾ªç¯
        function stopPreviewLoop() {
            if (previewAnimationId) {
                cancelAnimationFrame(previewAnimationId);
                previewAnimationId = null;
            }
        }

        // åº”ç”¨é¢„è§ˆæ»¤é•œ
        function applyPreviewFilter(color) {
            let config;
            if (isUsingCustomColor) {
                config = customColor;
            } else {
                config = colorConfigs[color];
            }
            if (!config) return;

            const imageData = previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height);
            const data = imageData.data;

            // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼
            let sum = 0;
            let count = 0;
            const grays = [];
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = r * 0.299 + g * 0.587 + b * 0.114;
                grays.push(gray);
                sum += gray;
                count++;
            }
            
            const avgThreshold = sum / count;
            const threshold = avgThreshold * 0.85;
            const contrast = 2.0;

            // åº”ç”¨å‰ªå½±æ•ˆæœ
            for (let i = 0; i < data.length; i += 4) {
                let gray = grays[i / 4];
                gray = ((gray - 128) * contrast) + 128;
                gray = Math.max(0, Math.min(255, gray));

                if (gray < threshold) {
                    data[i] = 0;
                    data[i + 1] = 0;
                    data[i + 2] = 0;
                } else {
                    data[i] = config.r;
                    data[i + 1] = config.g;
                    data[i + 2] = config.b;
                }
            }

            previewCtx.putImageData(imageData, 0, 0);
        }

        // å¯åŠ¨æ‘„åƒå¤´
        async function startCamera(facingMode = null) {
            // åœæ­¢å½“å‰æµ
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }

            // ä½¿ç”¨ä¼ å…¥çš„facingModeæˆ–å½“å‰è®¾ç½®
            const targetFacingMode = facingMode || currentFacingMode;

            try {
                const constraints = {
                    video: {
                        facingMode: targetFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                currentFacingMode = targetFacingMode;
                
                // æ›´æ–°æŒ‰é’®æ˜¾ç¤º
                updateSwitchButtonIcon();
            } catch (error) {
                // å¦‚æœè¯·æ±‚çš„æ‘„åƒå¤´å¤±è´¥ï¼Œå°è¯•å¦ä¸€ä¸ª
                const fallbackMode = targetFacingMode === 'environment' ? 'user' : 'environment';
                try {
                    const constraints = {
                        video: {
                            facingMode: fallbackMode,
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        }
                    };
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    currentFacingMode = fallbackMode;
                    updateSwitchButtonIcon();
                } catch (err) {
                    throw new Error('æ— æ³•è®¿é—®æ‘„åƒå¤´');
                }
            }
        }

        // åˆ‡æ¢æ‘„åƒå¤´
        async function switchCamera() {
            try {
                showLoading(true);
                const newFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
                await startCamera(newFacingMode);
                showLoading(false);
            } catch (error) {
                showLoading(false);
                showError('åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥');
                console.error('åˆ‡æ¢æ‘„åƒå¤´é”™è¯¯:', error);
            }
        }

        // æ›´æ–°åˆ‡æ¢æŒ‰é’®å›¾æ ‡
        function updateSwitchButtonIcon() {
            if (currentFacingMode === 'environment') {
                switchCameraBtn.textContent = 'ğŸ”„';
                switchCameraBtn.title = 'åˆ‡æ¢åˆ°å‰ç½®æ‘„åƒå¤´';
            } else {
                switchCameraBtn.textContent = 'ğŸ”„';
                switchCameraBtn.title = 'åˆ‡æ¢åˆ°åç½®æ‘„åƒå¤´';
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // é¢œè‰²æŒ‰é’®
            colorButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    colorButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentColor = btn.dataset.color;
                    isUsingCustomColor = false;
                    // é¢œè‰²æ”¹å˜æ—¶ï¼Œé¢„è§ˆä¼šè‡ªåŠ¨æ›´æ–°ï¼ˆé€šè¿‡requestAnimationFrameï¼‰
                });
            });

            // è‰²ç¯é€‰æ‹©å™¨åˆ‡æ¢
            colorPickerToggle.addEventListener('click', () => {
                const isVisible = colorWheelContainer.style.display !== 'none';
                colorWheelContainer.style.display = isVisible ? 'none' : 'flex';
            });

            // è‰²ç¯ç‚¹å‡»äº‹ä»¶
            colorWheel.addEventListener('click', (e) => {
                const rect = colorWheel.getBoundingClientRect();
                const x = e.clientX;
                const y = e.clientY;
                const color = getColorFromWheel(x, y);
                
                if (color) {
                    customColor = color;
                    isUsingCustomColor = true;
                    
                    // æ›´æ–°æŒ‡ç¤ºå™¨ä½ç½®
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const dx = x - centerX;
                    const dy = y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const radius = rect.width / 2 - 10;
                    const finalDistance = Math.min(distance, radius);
                    const angle = Math.atan2(dy, dx);
                    
                    colorIndicator.style.left = (centerX + Math.cos(angle) * finalDistance - rect.left) + 'px';
                    colorIndicator.style.top = (centerY + Math.sin(angle) * finalDistance - rect.top) + 'px';
                    
                    // æ›´æ–°é¢œè‰²æ˜¾ç¤º
                    selectedColorDisplay.style.backgroundColor = `rgb(${color.r}, ${color.g}, ${color.b})`;
                    
                    // å–æ¶ˆé¢„è®¾é¢œè‰²çš„é€‰ä¸­çŠ¶æ€
                    colorButtons.forEach(b => b.classList.remove('active'));
                }
            });

            // è‰²ç¯æ‹–æ‹½äº‹ä»¶
            let isDragging = false;
            colorWheel.addEventListener('mousedown', (e) => {
                isDragging = true;
                const rect = colorWheel.getBoundingClientRect();
                const x = e.clientX;
                const y = e.clientY;
                const color = getColorFromWheel(x, y);
                if (color) {
                    customColor = color;
                    isUsingCustomColor = true;
                    updateColorFromWheel(x, y, rect);
                    colorButtons.forEach(b => b.classList.remove('active'));
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const rect = colorWheel.getBoundingClientRect();
                    const x = e.clientX;
                    const y = e.clientY;
                    const color = getColorFromWheel(x, y);
                    if (color) {
                        customColor = color;
                        updateColorFromWheel(x, y, rect);
                    }
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
            colorWheel.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                const touch = e.touches[0];
                const rect = colorWheel.getBoundingClientRect();
                const x = touch.clientX;
                const y = touch.clientY;
                const color = getColorFromWheel(x, y);
                if (color) {
                    customColor = color;
                    isUsingCustomColor = true;
                    updateColorFromWheel(x, y, rect);
                    colorButtons.forEach(b => b.classList.remove('active'));
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = colorWheel.getBoundingClientRect();
                    const x = touch.clientX;
                    const y = touch.clientY;
                    const color = getColorFromWheel(x, y);
                    if (color) {
                        customColor = color;
                        updateColorFromWheel(x, y, rect);
                    }
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });

            // æ›´æ–°è‰²ç¯é¢œè‰²
            function updateColorFromWheel(x, y, rect) {
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const radius = rect.width / 2 - 10;
                const finalDistance = Math.min(distance, radius);
                const angle = Math.atan2(dy, dx);
                
                colorIndicator.style.left = (centerX + Math.cos(angle) * finalDistance - rect.left) + 'px';
                colorIndicator.style.top = (centerY + Math.sin(angle) * finalDistance - rect.top) + 'px';
                
                selectedColorDisplay.style.backgroundColor = `rgb(${customColor.r}, ${customColor.g}, ${customColor.b})`;
            }

            // ä¸Šä¼ æŒ‰é’®
            uploadBtn.addEventListener('click', () => {
                fileInput.click();
            });

            // æ–‡ä»¶é€‰æ‹©äº‹ä»¶
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    handleImageUpload(file);
                }
            });

            // æ­£æ–¹å½¢æ¨¡å¼æŒ‰é’®
            squareModeBtn.addEventListener('click', () => {
                isSquareMode = !isSquareMode;
                if (isSquareMode) {
                    squareModeBtn.classList.add('active');
                    squareModeBtn.textContent = 'â¬œ';
                    squareModeBtn.title = 'å…³é—­æ­£æ–¹å½¢æ¨¡å¼';
                    squareFrame.classList.add('active');
                } else {
                    squareModeBtn.classList.remove('active');
                    squareModeBtn.textContent = 'â¬œ';
                    squareModeBtn.title = 'æ­£æ–¹å½¢æ¨¡å¼';
                    squareFrame.classList.remove('active');
                }
            });

            // æ‹æ‘„æŒ‰é’®
            captureBtn.addEventListener('click', capturePhoto);

            // é‡ç½®æŒ‰é’®
            resetBtn.addEventListener('click', reset);

            // ä¸‹è½½æŒ‰é’®
            downloadBtn.addEventListener('click', downloadPoster);

            // å…³é—­ç»“æœ
            closeResultBtn.addEventListener('click', () => {
                resultSection.style.display = 'none';
                // é‡æ–°å¯åŠ¨é¢„è§ˆå¾ªç¯ï¼ˆå¦‚æœä½¿ç”¨æ‘„åƒå¤´ï¼‰
                if (!isUsingUploadedImage && stream) {
                    startPreviewLoop();
                } else if (isUsingUploadedImage && uploadedImage) {
                    // å¦‚æœä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡ï¼Œç»§ç»­å›¾ç‰‡é¢„è§ˆ
                    startPreviewLoop();
                }
            });

            // åˆ‡æ¢æ‘„åƒå¤´
            switchCameraBtn.addEventListener('click', switchCamera);

            // ç¼©æ”¾æ§åˆ¶
            zoomSlider.addEventListener('input', (e) => {
                currentZoom = parseFloat(e.target.value);
                applyZoom(currentZoom);
                updateZoomValue();
            });

            zoomInBtn.addEventListener('click', () => {
                if (currentZoom < 3) {
                    currentZoom = Math.min(3, currentZoom + 0.1);
                    zoomSlider.value = currentZoom;
                    applyZoom(currentZoom);
                    updateZoomValue();
                }
            });

            zoomOutBtn.addEventListener('click', () => {
                if (currentZoom > 0.3) {
                    currentZoom = Math.max(0.3, currentZoom - 0.1);
                    zoomSlider.value = currentZoom;
                    applyZoom(currentZoom);
                    updateZoomValue();
                }
            });

            // åŒæŒ‡æåˆç¼©æ”¾æ‰‹åŠ¿
            let touches = [];
            cameraSection.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    touches = Array.from(e.touches);
                    initialDistance = getDistance(touches[0], touches[1]);
                    lastZoom = currentZoom;
                }
            }, { passive: true });

            cameraSection.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && touches.length === 2) {
                    e.preventDefault();
                    const currentDistance = getDistance(e.touches[0], e.touches[1]);
                    const scale = currentDistance / initialDistance;
                    const newZoom = Math.max(0.3, Math.min(3, lastZoom * scale));
                    currentZoom = newZoom;
                    zoomSlider.value = currentZoom;
                    applyZoom(currentZoom);
                    updateZoomValue();
                }
            }, { passive: false });

            cameraSection.addEventListener('touchend', () => {
                touches = [];
            }, { passive: true });

            // æ–¹å‘é”å®šæŒ‰é’®
            orientationBtn.addEventListener('click', toggleOrientationLock);

            // æ£€æµ‹è®¾å¤‡æ–¹å‘å˜åŒ–
            if (window.DeviceOrientationEvent) {
                window.addEventListener('orientationchange', handleOrientationChange);
                handleOrientationChange(); // åˆå§‹åŒ–æ–¹å‘
            } else if (window.screen && window.screen.orientation) {
                window.screen.orientation.addEventListener('change', handleOrientationChange);
                handleOrientationChange();
            } else {
                // ä½¿ç”¨resizeäº‹ä»¶ä½œä¸ºåå¤‡æ–¹æ¡ˆ
                window.addEventListener('resize', handleOrientationChange);
                handleOrientationChange();
            }
        }

        // åˆ‡æ¢æ–¹å‘é”å®š
        function toggleOrientationLock() {
            orientationLocked = !orientationLocked;
            if (orientationLocked) {
                orientationBtn.textContent = 'ğŸ”’';
                orientationBtn.title = 'è§£é”æ–¹å‘';
                orientationBtn.classList.add('locked');
            } else {
                orientationBtn.textContent = 'ğŸ”“';
                orientationBtn.title = 'é”å®šæ–¹å‘';
                orientationBtn.classList.remove('locked');
                handleOrientationChange(); // ç«‹å³åº”ç”¨å½“å‰æ–¹å‘
            }
        }

        // å¤„ç†æ–¹å‘å˜åŒ–
        function handleOrientationChange() {
            if (orientationLocked) return;

            const width = window.innerWidth;
            const height = window.innerHeight;
            const isLandscape = width > height;

            // ä½¿ç”¨å±å¹•æ–¹å‘APIï¼ˆå¦‚æœå¯ç”¨ï¼‰
            let screenOrientation = 'portrait';
            if (window.screen && window.screen.orientation) {
                const angle = window.screen.orientation.angle;
                screenOrientation = (angle === 90 || angle === 270) ? 'landscape' : 'portrait';
            } else {
                screenOrientation = isLandscape ? 'landscape' : 'portrait';
            }

            if (screenOrientation === 'landscape' && currentOrientation !== 'landscape') {
                currentOrientation = 'landscape';
                cameraSection.classList.add('landscape');
                video.style.objectFit = 'contain';
            } else if (screenOrientation === 'portrait' && currentOrientation !== 'portrait') {
                currentOrientation = 'portrait';
                cameraSection.classList.remove('landscape');
                video.style.objectFit = 'cover';
            }
        }

        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // åº”ç”¨ç¼©æ”¾
        function applyZoom(zoom) {
            // åªæœ‰åœ¨ä½¿ç”¨æ‘„åƒå¤´æ—¶æ‰ç¼©æ”¾videoå…ƒç´ 
            if (!isUsingUploadedImage && video) {
                video.style.transform = `scale(${zoom})`;
            }
            // é¢„è§ˆcanvaså§‹ç»ˆå¯ä»¥ç¼©æ”¾
            if (previewCanvas) {
                previewCanvas.style.transform = `scale(${zoom})`;
            }
        }

        // æ›´æ–°ç¼©æ”¾å€¼æ˜¾ç¤º
        function updateZoomValue() {
            zoomValue.textContent = currentZoom.toFixed(1) + 'x';
        }


        // æ‹æ‘„ç…§ç‰‡
        async function capturePhoto() {
            // å¦‚æœä½¿ç”¨ä¸Šä¼ çš„å›¾ç‰‡ï¼Œç›´æ¥å¤„ç†å›¾ç‰‡
            if (isUsingUploadedImage && uploadedImage) {
                processUploadedImage();
                return;
            }

            if (!stream) {
                showError('æ‘„åƒå¤´æœªå¯åŠ¨');
                return;
            }

            try {
                showLoading(true);
                
                // è®¾ç½®canvaså°ºå¯¸ï¼ˆæ ¹æ®å½“å‰æ–¹å‘ï¼‰
                const videoWidth = video.videoWidth;
                const videoHeight = video.videoHeight;
                const isVideoLandscape = videoWidth > videoHeight;
                
                let canvasWidth, canvasHeight;
                let needRotate = false;
                
                // æ ¹æ®å½“å‰å±å¹•æ–¹å‘å†³å®šcanvaså°ºå¯¸
                if (currentOrientation === 'landscape') {
                    // æ¨ªå±æ¨¡å¼ï¼šcanvasåº”è¯¥æ˜¯æ¨ªå‘çš„
                    if (isVideoLandscape) {
                        // è§†é¢‘æœ¬èº«å°±æ˜¯æ¨ªå±ï¼Œç›´æ¥ä½¿ç”¨
                        canvasWidth = videoWidth;
                        canvasHeight = videoHeight;
                        needRotate = false;
                    } else {
                        // è§†é¢‘æ˜¯ç«–å±ï¼Œéœ€è¦æ—‹è½¬90åº¦å˜æˆæ¨ªå±
                        canvasWidth = videoHeight;
                        canvasHeight = videoWidth;
                        needRotate = true;
                    }
                } else {
                    // ç«–å±æ¨¡å¼ï¼šcanvasåº”è¯¥æ˜¯ç«–å‘çš„
                    if (isVideoLandscape) {
                        // è§†é¢‘æ˜¯æ¨ªå±ï¼Œéœ€è¦æ—‹è½¬90åº¦å˜æˆç«–å±
                        canvasWidth = videoHeight;
                        canvasHeight = videoWidth;
                        needRotate = true;
                    } else {
                        // è§†é¢‘æœ¬èº«å°±æ˜¯ç«–å±ï¼Œç›´æ¥ä½¿ç”¨
                        canvasWidth = videoWidth;
                        canvasHeight = videoHeight;
                        needRotate = false;
                    }
                }
                
                // è®¡ç®—ç¼©æ”¾åçš„å®é™…å°ºå¯¸
                const scaledWidth = videoWidth * currentZoom;
                const scaledHeight = videoHeight * currentZoom;
                
                // åˆ›å»ºä¸´æ—¶canvasæ¥å¤„ç†ç¼©æ”¾å’Œæ—‹è½¬
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // å…ˆç»˜åˆ¶åˆ°ä¸´æ—¶canvasï¼ˆåŸå§‹å°ºå¯¸ï¼‰
                tempCanvas.width = videoWidth;
                tempCanvas.height = videoHeight;
                
                // åœ¨ä¸´æ—¶canvasä¸Šç»˜åˆ¶ç¼©æ”¾åçš„è§†é¢‘
                const offsetX = (videoWidth - scaledWidth) / 2;
                const offsetY = (videoHeight - scaledHeight) / 2;
                tempCtx.drawImage(video, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // åº”ç”¨é¢œè‰²æ»¤é•œåˆ°ä¸´æ—¶canvas
                const tempImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const tempData = tempImageData.data;
                const config = isUsingCustomColor ? customColor : colorConfigs[currentColor];
                
                // è®¡ç®—é˜ˆå€¼å¹¶åº”ç”¨å‰ªå½±æ•ˆæœ
                let sum = 0;
                const grays = [];
                for (let i = 0; i < tempData.length; i += 4) {
                    const gray = tempData[i] * 0.299 + tempData[i + 1] * 0.587 + tempData[i + 2] * 0.114;
                    grays.push(gray);
                    sum += gray;
                }
                const avgThreshold = sum / (tempData.length / 4);
                const threshold = avgThreshold * 0.85;
                const contrast = 2.0;
                
                for (let i = 0; i < tempData.length; i += 4) {
                    let gray = grays[i / 4];
                    gray = ((gray - 128) * contrast) + 128;
                    gray = Math.max(0, Math.min(255, gray));
                    
                    if (gray < threshold) {
                        tempData[i] = 0;
                        tempData[i + 1] = 0;
                        tempData[i + 2] = 0;
                    } else {
                        tempData[i] = config.r;
                        tempData[i + 1] = config.g;
                        tempData[i + 2] = config.b;
                    }
                }
                tempCtx.putImageData(tempImageData, 0, 0);
                
                // æ ¹æ®æ¨¡å¼å’Œç¼©æ”¾ç¡®å®šæœ€ç»ˆcanvaså°ºå¯¸
                let finalWidth, finalHeight;
                
                if (isSquareMode) {
                    const originalSize = Math.min(canvasWidth, canvasHeight);
                    finalWidth = originalSize * currentZoom;
                    finalHeight = originalSize * currentZoom;
                } else {
                    if (needRotate) {
                        finalWidth = scaledHeight;
                        finalHeight = scaledWidth;
                    } else {
                        finalWidth = scaledWidth;
                        finalHeight = scaledHeight;
                    }
                }
                
                // è®¾ç½®æœ€ç»ˆcanvaså°ºå¯¸ï¼ˆå®Œå…¨åŒ¹é…å›¾åƒå°ºå¯¸ï¼Œæ— ç™½è‰²èƒŒæ™¯ï¼‰
                canvas.width = finalWidth;
                canvas.height = finalHeight;
                
                // ç»˜åˆ¶åˆ°æœ€ç»ˆcanvas
                ctx.save();
                
                if (isSquareMode) {
                    // æ­£æ–¹å½¢æ¨¡å¼ï¼šä»ä¸´æ—¶canvasè£å‰ªä¸­å¿ƒæ­£æ–¹å½¢
                    const originalSize = Math.min(canvasWidth, canvasHeight);
                    const sourceX = (videoWidth - originalSize) / 2;
                    const sourceY = (videoHeight - originalSize) / 2;
                    ctx.drawImage(tempCanvas, sourceX, sourceY, originalSize, originalSize, 0, 0, finalWidth, finalHeight);
                } else {
                    if (needRotate) {
                        // éœ€è¦æ—‹è½¬ï¼šå…ˆæ—‹è½¬ä¸´æ—¶canvasï¼Œå†ç»˜åˆ¶
                        const rotatedCanvas = document.createElement('canvas');
                        const rotatedCtx = rotatedCanvas.getContext('2d');
                        rotatedCanvas.width = videoHeight;
                        rotatedCanvas.height = videoWidth;
                        
                        rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
                        rotatedCtx.rotate(Math.PI / 2);
                        rotatedCtx.translate(-tempCanvas.height / 2, -tempCanvas.width / 2);
                        rotatedCtx.drawImage(tempCanvas, 0, 0);
                        
                        // ä»æ—‹è½¬åçš„canvasè£å‰ªç¼©æ”¾åçš„åŒºåŸŸ
                        const cropX = (rotatedCanvas.width - scaledHeight) / 2;
                        const cropY = (rotatedCanvas.height - scaledWidth) / 2;
                        ctx.drawImage(rotatedCanvas, cropX, cropY, scaledHeight, scaledWidth, 0, 0, finalWidth, finalHeight);
                    } else {
                        // ä¸éœ€è¦æ—‹è½¬ï¼šç›´æ¥ç»˜åˆ¶ç¼©æ”¾åçš„åŒºåŸŸ
                        ctx.drawImage(tempCanvas, offsetX, offsetY, scaledWidth, scaledHeight, 0, 0, finalWidth, finalHeight);
                    }
                }
                
                ctx.restore();
                
                // é¢œè‰²æ»¤é•œå·²ç»åœ¨ä¸´æ—¶canvasä¸Šåº”ç”¨äº†ï¼Œè¿™é‡Œä¸éœ€è¦å†æ¬¡åº”ç”¨

                // æ˜¾ç¤ºç»“æœ
                resultImage.src = canvas.toDataURL('image/png');
                resultSection.style.display = 'flex';
                showLoading(false);
                
                // åœæ­¢é¢„è§ˆå¾ªç¯ä»¥èŠ‚çœæ€§èƒ½
                stopPreviewLoop();
            } catch (error) {
                showLoading(false);
                showError('æ‹æ‘„å¤±è´¥ï¼Œè¯·é‡è¯•');
                console.error('æ‹æ‘„é”™è¯¯:', error);
            }
        }

        // å¤„ç†ä¸Šä¼ çš„å›¾ç‰‡
        function processUploadedImage() {
            if (!uploadedImage) return;

            try {
                showLoading(true);

                const imgWidth = uploadedImage.width;
                const imgHeight = uploadedImage.height;
                const isImageLandscape = imgWidth > imgHeight;

                let canvasWidth, canvasHeight;
                let needRotate = false;

                // æ ¹æ®å½“å‰å±å¹•æ–¹å‘å†³å®šcanvaså°ºå¯¸
                if (currentOrientation === 'landscape') {
                    if (isImageLandscape) {
                        canvasWidth = imgWidth;
                        canvasHeight = imgHeight;
                        needRotate = false;
                    } else {
                        canvasWidth = imgHeight;
                        canvasHeight = imgWidth;
                        needRotate = true;
                    }
                } else {
                    if (isImageLandscape) {
                        canvasWidth = imgHeight;
                        canvasHeight = imgWidth;
                        needRotate = true;
                    } else {
                        canvasWidth = imgWidth;
                        canvasHeight = imgHeight;
                        needRotate = false;
                    }
                }

                // è®¡ç®—ç¼©æ”¾åçš„å®é™…å°ºå¯¸
                const scaledWidth = imgWidth * currentZoom;
                const scaledHeight = imgHeight * currentZoom;
                
                // åˆ›å»ºä¸´æ—¶canvasæ¥å¤„ç†ç¼©æ”¾å’Œæ—‹è½¬
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                
                // å…ˆç»˜åˆ¶åˆ°ä¸´æ—¶canvasï¼ˆåŸå§‹å°ºå¯¸ï¼‰
                tempCanvas.width = imgWidth;
                tempCanvas.height = imgHeight;
                
                // åœ¨ä¸´æ—¶canvasä¸Šç»˜åˆ¶ç¼©æ”¾åçš„å›¾ç‰‡
                const offsetX = (imgWidth - scaledWidth) / 2;
                const offsetY = (imgHeight - scaledHeight) / 2;
                tempCtx.drawImage(uploadedImage, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // åº”ç”¨é¢œè‰²æ»¤é•œåˆ°ä¸´æ—¶canvas
                const tempImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const tempData = tempImageData.data;
                const config = isUsingCustomColor ? customColor : colorConfigs[currentColor];
                
                // è®¡ç®—é˜ˆå€¼å¹¶åº”ç”¨å‰ªå½±æ•ˆæœ
                let sum = 0;
                const grays = [];
                for (let i = 0; i < tempData.length; i += 4) {
                    const gray = tempData[i] * 0.299 + tempData[i + 1] * 0.587 + tempData[i + 2] * 0.114;
                    grays.push(gray);
                    sum += gray;
                }
                const avgThreshold = sum / (tempData.length / 4);
                const threshold = avgThreshold * 0.85;
                const contrast = 2.0;
                
                for (let i = 0; i < tempData.length; i += 4) {
                    let gray = grays[i / 4];
                    gray = ((gray - 128) * contrast) + 128;
                    gray = Math.max(0, Math.min(255, gray));
                    
                    if (gray < threshold) {
                        tempData[i] = 0;
                        tempData[i + 1] = 0;
                        tempData[i + 2] = 0;
                    } else {
                        tempData[i] = config.r;
                        tempData[i + 1] = config.g;
                        tempData[i + 2] = config.b;
                    }
                }
                tempCtx.putImageData(tempImageData, 0, 0);
                
                // æ ¹æ®æ¨¡å¼å’Œç¼©æ”¾ç¡®å®šæœ€ç»ˆcanvaså°ºå¯¸
                let finalWidth, finalHeight;
                
                if (isSquareMode) {
                    const originalSize = Math.min(canvasWidth, canvasHeight);
                    finalWidth = originalSize * currentZoom;
                    finalHeight = originalSize * currentZoom;
                } else {
                    if (needRotate) {
                        finalWidth = scaledHeight;
                        finalHeight = scaledWidth;
                    } else {
                        finalWidth = scaledWidth;
                        finalHeight = scaledHeight;
                    }
                }
                
                // è®¾ç½®æœ€ç»ˆcanvaså°ºå¯¸ï¼ˆå®Œå…¨åŒ¹é…å›¾åƒå°ºå¯¸ï¼Œæ— ç™½è‰²èƒŒæ™¯ï¼‰
                canvas.width = finalWidth;
                canvas.height = finalHeight;
                
                // ç»˜åˆ¶åˆ°æœ€ç»ˆcanvas
                ctx.save();
                
                if (isSquareMode) {
                    // æ­£æ–¹å½¢æ¨¡å¼ï¼šä»ä¸´æ—¶canvasè£å‰ªä¸­å¿ƒæ­£æ–¹å½¢
                    const originalSize = Math.min(canvasWidth, canvasHeight);
                    const sourceX = (imgWidth - originalSize) / 2;
                    const sourceY = (imgHeight - originalSize) / 2;
                    ctx.drawImage(tempCanvas, sourceX, sourceY, originalSize, originalSize, 0, 0, finalWidth, finalHeight);
                } else {
                    if (needRotate) {
                        // éœ€è¦æ—‹è½¬ï¼šå…ˆæ—‹è½¬ä¸´æ—¶canvasï¼Œå†ç»˜åˆ¶
                        const rotatedCanvas = document.createElement('canvas');
                        const rotatedCtx = rotatedCanvas.getContext('2d');
                        rotatedCanvas.width = imgHeight;
                        rotatedCanvas.height = imgWidth;
                        
                        rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
                        rotatedCtx.rotate(Math.PI / 2);
                        rotatedCtx.translate(-tempCanvas.height / 2, -tempCanvas.width / 2);
                        rotatedCtx.drawImage(tempCanvas, 0, 0);
                        
                        // ä»æ—‹è½¬åçš„canvasè£å‰ªç¼©æ”¾åçš„åŒºåŸŸ
                        const cropX = (rotatedCanvas.width - scaledHeight) / 2;
                        const cropY = (rotatedCanvas.height - scaledWidth) / 2;
                        ctx.drawImage(rotatedCanvas, cropX, cropY, scaledHeight, scaledWidth, 0, 0, finalWidth, finalHeight);
                    } else {
                        // ä¸éœ€è¦æ—‹è½¬ï¼šç›´æ¥ç»˜åˆ¶ç¼©æ”¾åçš„åŒºåŸŸ
                        ctx.drawImage(tempCanvas, offsetX, offsetY, scaledWidth, scaledHeight, 0, 0, finalWidth, finalHeight);
                    }
                }
                
                ctx.restore();
                
                // é¢œè‰²æ»¤é•œå·²ç»åœ¨ä¸´æ—¶canvasä¸Šåº”ç”¨äº†ï¼Œè¿™é‡Œä¸éœ€è¦å†æ¬¡åº”ç”¨

                // æ˜¾ç¤ºç»“æœ
                resultImage.src = canvas.toDataURL('image/png');
                resultSection.style.display = 'flex';
                showLoading(false);
            } catch (error) {
                showLoading(false);
                showError('å¤„ç†å›¾ç‰‡å¤±è´¥ï¼Œè¯·é‡è¯•');
                console.error('å¤„ç†å›¾ç‰‡é”™è¯¯:', error);
            }
        }

        // åº”ç”¨é¢œè‰²æ»¤é•œ - å®ç°å‰ªå½±æ•ˆæœï¼ˆçº¯é»‘å‰ªå½± + çº¯è‰²èƒŒæ™¯ï¼‰
        function applyColorFilter(color) {
            let config;
            if (isUsingCustomColor) {
                config = customColor;
            } else {
                config = colorConfigs[color];
            }
            if (!config) return;

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼ï¼ˆä½¿ç”¨Otsuæ–¹æ³•æˆ–ç®€å•å¹³å‡å€¼ï¼‰
            let sum = 0;
            let count = 0;
            const grays = [];
            
            // å…ˆè®¡ç®—æ‰€æœ‰åƒç´ çš„ç°åº¦å€¼
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = r * 0.299 + g * 0.587 + b * 0.114;
                grays.push(gray);
                sum += gray;
                count++;
            }
            
            // ä½¿ç”¨å¹³å‡å€¼ä½œä¸ºé˜ˆå€¼ï¼Œæˆ–ä½¿ç”¨ä¸­ä½æ•°
            const avgThreshold = sum / count;
            // ç¨å¾®è°ƒæ•´é˜ˆå€¼ï¼Œä½¿å‰ªå½±æ›´æ˜æ˜¾ï¼ˆé™ä½é˜ˆå€¼ä¼šè®©æ›´å¤šåŒºåŸŸå˜æˆé»‘è‰²ï¼‰
            const threshold = avgThreshold * 0.85;
            
            // é«˜å¯¹æ¯”åº¦å‚æ•°
            const contrast = 2.0;

            // åº”ç”¨å‰ªå½±æ•ˆæœ
            for (let i = 0; i < data.length; i += 4) {
                let gray = grays[i / 4];

                // å¢å¼ºå¯¹æ¯”åº¦
                gray = ((gray - 128) * contrast) + 128;
                gray = Math.max(0, Math.min(255, gray));

                // é˜ˆå€¼åŒ–ï¼šä½äºé˜ˆå€¼çš„å˜æˆçº¯é»‘è‰²ï¼Œé«˜äºé˜ˆå€¼çš„å˜æˆä¸»é¢˜é¢œè‰²
                if (gray < threshold) {
                    // çº¯é»‘è‰²å‰ªå½±
                    data[i] = 0;
                    data[i + 1] = 0;
                    data[i + 2] = 0;
                } else {
                    // çº¯è‰²èƒŒæ™¯
                    data[i] = config.r;
                    data[i + 1] = config.g;
                    data[i + 2] = config.b;
                }
                // alphaé€šé“ä¿æŒä¸å˜
            }

            ctx.putImageData(imageData, 0, 0);
        }


        // ä¸‹è½½æµ·æŠ¥
        function downloadPoster() {
            const link = document.createElement('a');
            link.download = `æµ·æŠ¥_${new Date().getTime()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // é‡ç½®
        function reset() {
            currentColor = 'red';
            isUsingCustomColor = false;
            customColor = { r: 255, g: 71, b: 87 }; // é‡ç½®ä¸ºçº¢è‰²
            colorButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.color === 'red') {
                    btn.classList.add('active');
                }
            });
            // é‡ç½®è‰²ç¯æ˜¾ç¤º
            selectedColorDisplay.style.backgroundColor = `rgb(${customColor.r}, ${customColor.g}, ${customColor.b})`;
            colorWheelContainer.style.display = 'none';
            // é‡ç½®ç¼©æ”¾
            currentZoom = 1.0;
            zoomSlider.value = 1.0;
            applyZoom(1.0);
            updateZoomValue();
            // é‡ç½®æ–¹å‘é”å®š
            if (orientationLocked) {
                toggleOrientationLock();
            }
            // é‡ç½®æ­£æ–¹å½¢æ¨¡å¼
            isSquareMode = false;
            squareModeBtn.classList.remove('active');
            squareFrame.classList.remove('active');
            // é‡ç½®ä¸Šä¼ çš„å›¾ç‰‡
            isUsingUploadedImage = false;
            uploadedImage = null;
            fileInput.value = '';
            // å¦‚æœæ‘„åƒå¤´åœ¨è¿è¡Œï¼Œæ¢å¤è§†é¢‘é¢„è§ˆ
            if (stream) {
                stopPreviewLoop();
                startPreviewLoop();
            }
        }

        // æ˜¾ç¤ºåŠ è½½
        function showLoading(show) {
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        // æ˜¾ç¤ºé”™è¯¯
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('show');
            setTimeout(() => {
                errorMessage.classList.remove('show');
            }, 3000);
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.addEventListener('load', () => {
            init();
            registerServiceWorker();
        });

        // æ³¨å†ŒService Worker
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('./service-worker.js')
                    .then((registration) => {
                        console.log('Service Worker registered:', registration);
                    })
                    .catch((error) => {
                        console.log('Service Worker registration failed:', error);
                    });
            }
        }

        // é¡µé¢å¸è½½æ—¶åœæ­¢æ‘„åƒå¤´å’Œé¢„è§ˆ
        window.addEventListener('beforeunload', () => {
            stopPreviewLoop();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
